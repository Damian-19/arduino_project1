
Project1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  000003c0  00000454  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000003c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  00800106  00800106  0000045a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000045a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000048c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000048  00000000  00000000  000004cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000819  00000000  00000000  00000514  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000006bc  00000000  00000000  00000d2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000414  00000000  00000000  000013e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e0  00000000  00000000  00001800  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003df  00000000  00000000  000018e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001c3  00000000  00000000  00001cbf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  00001e82  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 4b 01 	jmp	0x296	; 0x296 <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 97 01 	jmp	0x32e	; 0x32e <__vector_21>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 ec       	ldi	r30, 0xC0	; 192
  7c:	f3 e0       	ldi	r31, 0x03	; 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a6 30       	cpi	r26, 0x06	; 6
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a6 e0       	ldi	r26, 0x06	; 6
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a0 31       	cpi	r26, 0x10	; 16
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 30 01 	call	0x260	; 0x260 <main>
  9e:	0c 94 de 01 	jmp	0x3bc	; 0x3bc <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <init>:
*initialization function 
***************************/
void init(void)
{
	//Set PortD to all outputs because LEDs are connected to this PORT
	DDRD = 0xff;	// 0xff = 0b11111111; all ones
  a6:	8f ef       	ldi	r24, 0xFF	; 255
  a8:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0;		// 
  aa:	1b b8       	out	0x0b, r1	; 11
	DDRB = 0b00000000; // set PORTB to inputs
  ac:	14 b8       	out	0x04, r1	; 4
	PORTB = 0b00110000; // enable pull up resistors on pins 4 & 5
  ae:	80 e3       	ldi	r24, 0x30	; 48
  b0:	85 b9       	out	0x05, r24	; 5
	
	timecount0 = 0;
  b2:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <timecount0+0x1>
  b6:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <timecount0>
	TCCR0B = (5<<CS00);	// Set T0 Source = Clock (16MHz)/1024 and put Timer in Normal mode
  ba:	85 e0       	ldi	r24, 0x05	; 5
  bc:	85 bd       	out	0x25, r24	; 37
	
	TCCR0A = 0;			// Not strictly necessary as these are the reset states but it's good
  be:	14 bc       	out	0x24, r1	; 36
	// practice to show what you're doing
	TCNT0 = tcnt0_start;			// Recall: 256-61 = 195 & 195*64us = 12.48ms, approx 12.5ms
  c0:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <tcnt0_start>
  c4:	86 bd       	out	0x26, r24	; 38
	TIMSK0 = (1<<TOIE0);	// Enable Timer 0 interrupt
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
	
	// ADC initialization
	ADMUX = ((1<<REFS0) | (0 << ADLAR) | (0<<MUX0));  /* AVCC selected for VREF, ADC0 as ADC input  */
  cc:	80 e4       	ldi	r24, 0x40	; 64
  ce:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	ADCSRA = ((1<<ADEN)|(1<<ADSC)|(1<<ADATE)|(1<<ADIE)|(6<<ADPS0));
  d2:	8e ee       	ldi	r24, 0xEE	; 238
  d4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
										/* Enable ADC, Start Conversion, Auto Trigger enabled, 
										   Interrupt enabled, Prescale = 64  */
	ADCSRB = (0<<ADTS0); /* Select AutoTrigger Source to Free Running Mode 
  d8:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
						    Strictly speaking - this is already 0, so we could omit the write to
						    ADCSRB, but this is included here so the intent is clear */
	
	sei();				// Global interrupt enable (I=1)
  dc:	78 94       	sei
  de:	08 95       	ret

000000e0 <cylon_loop>:
*looping cylon pattern function
*********************************/
void cylon_loop(int end)
{
	// cylon pattern
	if (direction == 0) { // check if direction is down
  e0:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <__data_end>
  e4:	30 91 07 01 	lds	r19, 0x0107	; 0x800107 <__data_end+0x1>
  e8:	21 15       	cp	r18, r1
  ea:	31 05       	cpc	r19, r1
  ec:	e1 f4       	brne	.+56     	; 0x126 <cylon_loop+0x46>
		active_led--; // decrement the active led
  ee:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
  f2:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
  f6:	21 50       	subi	r18, 0x01	; 1
  f8:	31 09       	sbc	r19, r1
  fa:	30 93 01 01 	sts	0x0101, r19	; 0x800101 <__data_start+0x1>
  fe:	20 93 00 01 	sts	0x0100, r18	; 0x800100 <__data_start>
		if (active_led <= end) { // check if led has reached the start (pin 4 or 0)
 102:	82 17       	cp	r24, r18
 104:	93 07       	cpc	r25, r19
 106:	30 f0       	brcs	.+12     	; 0x114 <cylon_loop+0x34>
			direction = 1; // set direction to up
 108:	81 e0       	ldi	r24, 0x01	; 1
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <__data_end+0x1>
 110:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <__data_end>
		}
		PORTD = 0b00000001 << active_led; // set pin of portd to current led
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	02 c0       	rjmp	.+4      	; 0x11e <cylon_loop+0x3e>
 11a:	88 0f       	add	r24, r24
 11c:	99 1f       	adc	r25, r25
 11e:	2a 95       	dec	r18
 120:	e2 f7       	brpl	.-8      	; 0x11a <cylon_loop+0x3a>
 122:	8b b9       	out	0x0b, r24	; 11
 124:	08 95       	ret
		
		} else if (direction == 1) { // check if direction is up
 126:	21 30       	cpi	r18, 0x01	; 1
 128:	31 05       	cpc	r19, r1
 12a:	c9 f4       	brne	.+50     	; 0x15e <cylon_loop+0x7e>
		active_led++; // increment the active led
 12c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 130:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 134:	01 96       	adiw	r24, 0x01	; 1
 136:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 13a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
		if (active_led >= 7) { // check if led has reached end (pin 7)
 13e:	87 30       	cpi	r24, 0x07	; 7
 140:	91 05       	cpc	r25, r1
 142:	20 f0       	brcs	.+8      	; 0x14c <cylon_loop+0x6c>
			direction = 0; // set direction to down
 144:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <__data_end+0x1>
 148:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <__data_end>
		}
		PORTD = 0b00000001 << active_led; // set pin of portd to current led
 14c:	21 e0       	ldi	r18, 0x01	; 1
 14e:	30 e0       	ldi	r19, 0x00	; 0
 150:	a9 01       	movw	r20, r18
 152:	02 c0       	rjmp	.+4      	; 0x158 <cylon_loop+0x78>
 154:	44 0f       	add	r20, r20
 156:	55 1f       	adc	r21, r21
 158:	8a 95       	dec	r24
 15a:	e2 f7       	brpl	.-8      	; 0x154 <cylon_loop+0x74>
 15c:	4b b9       	out	0x0b, r20	; 11
 15e:	08 95       	ret

00000160 <adc_display>:
		}
}

void adc_display(int display_flag)
{
	if (display_flag == 1)
 160:	81 30       	cpi	r24, 0x01	; 1
 162:	91 05       	cpc	r25, r1
 164:	09 f0       	breq	.+2      	; 0x168 <adc_display+0x8>
 166:	4c c0       	rjmp	.+152    	; 0x200 <adc_display+0xa0>
	{
		if ((adc_reading >= 0) && (adc_reading <= 128))
 168:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <adc_reading>
 16c:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <adc_reading+0x1>
 170:	81 38       	cpi	r24, 0x81	; 129
 172:	91 05       	cpc	r25, r1
 174:	10 f4       	brcc	.+4      	; 0x17a <adc_display+0x1a>
		{
			PORTD = 0b00000000;
 176:	1b b8       	out	0x0b, r1	; 11
 178:	08 95       	ret
		} else if ((adc_reading >= 128) && (adc_reading <= 256))
 17a:	9c 01       	movw	r18, r24
 17c:	20 58       	subi	r18, 0x80	; 128
 17e:	31 09       	sbc	r19, r1
 180:	21 38       	cpi	r18, 0x81	; 129
 182:	31 05       	cpc	r19, r1
 184:	18 f4       	brcc	.+6      	; 0x18c <adc_display+0x2c>
		{
			PORTD = 0b00000001;
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	8b b9       	out	0x0b, r24	; 11
 18a:	08 95       	ret
		} else if ((adc_reading >= 256) && (adc_reading <= 384))
 18c:	9c 01       	movw	r18, r24
 18e:	3a 95       	dec	r19
 190:	21 38       	cpi	r18, 0x81	; 129
 192:	31 05       	cpc	r19, r1
 194:	18 f4       	brcc	.+6      	; 0x19c <adc_display+0x3c>
		{
			PORTD = 0b00000011;
 196:	83 e0       	ldi	r24, 0x03	; 3
 198:	8b b9       	out	0x0b, r24	; 11
 19a:	08 95       	ret
		} else if ((adc_reading >= 384) && (adc_reading <= 512))
 19c:	9c 01       	movw	r18, r24
 19e:	20 58       	subi	r18, 0x80	; 128
 1a0:	31 40       	sbci	r19, 0x01	; 1
 1a2:	21 38       	cpi	r18, 0x81	; 129
 1a4:	31 05       	cpc	r19, r1
 1a6:	18 f4       	brcc	.+6      	; 0x1ae <adc_display+0x4e>
		{
			PORTD = 0b00000111;
 1a8:	87 e0       	ldi	r24, 0x07	; 7
 1aa:	8b b9       	out	0x0b, r24	; 11
 1ac:	08 95       	ret
		} else if ((adc_reading >= 512) && (adc_reading <= 639))
 1ae:	9c 01       	movw	r18, r24
 1b0:	32 50       	subi	r19, 0x02	; 2
 1b2:	20 38       	cpi	r18, 0x80	; 128
 1b4:	31 05       	cpc	r19, r1
 1b6:	18 f4       	brcc	.+6      	; 0x1be <adc_display+0x5e>
		{
			PORTD = 0b00001111;
 1b8:	8f e0       	ldi	r24, 0x0F	; 15
 1ba:	8b b9       	out	0x0b, r24	; 11
 1bc:	08 95       	ret
		} else if ((adc_reading >= 639) && (adc_reading <= 767))
 1be:	9c 01       	movw	r18, r24
 1c0:	2f 57       	subi	r18, 0x7F	; 127
 1c2:	32 40       	sbci	r19, 0x02	; 2
 1c4:	21 38       	cpi	r18, 0x81	; 129
 1c6:	31 05       	cpc	r19, r1
 1c8:	18 f4       	brcc	.+6      	; 0x1d0 <adc_display+0x70>
		{
			PORTD = 0b00011111;
 1ca:	8f e1       	ldi	r24, 0x1F	; 31
 1cc:	8b b9       	out	0x0b, r24	; 11
 1ce:	08 95       	ret
		} else if ((adc_reading >= 767) && (adc_reading <= 895))
 1d0:	9c 01       	movw	r18, r24
 1d2:	2f 5f       	subi	r18, 0xFF	; 255
 1d4:	32 40       	sbci	r19, 0x02	; 2
 1d6:	21 38       	cpi	r18, 0x81	; 129
 1d8:	31 05       	cpc	r19, r1
 1da:	18 f4       	brcc	.+6      	; 0x1e2 <adc_display+0x82>
		{
			PORTD = 0b00111111;
 1dc:	8f e3       	ldi	r24, 0x3F	; 63
 1de:	8b b9       	out	0x0b, r24	; 11
 1e0:	08 95       	ret
		} else if ((adc_reading >= 895) && (adc_reading < 1023))
 1e2:	9c 01       	movw	r18, r24
 1e4:	2f 57       	subi	r18, 0x7F	; 127
 1e6:	33 40       	sbci	r19, 0x03	; 3
 1e8:	20 38       	cpi	r18, 0x80	; 128
 1ea:	31 05       	cpc	r19, r1
 1ec:	18 f4       	brcc	.+6      	; 0x1f4 <adc_display+0x94>
		{
			PORTD = 0b01111111;
 1ee:	8f e7       	ldi	r24, 0x7F	; 127
 1f0:	8b b9       	out	0x0b, r24	; 11
 1f2:	08 95       	ret
		} else if (adc_reading == 1023)
 1f4:	8f 3f       	cpi	r24, 0xFF	; 255
 1f6:	93 40       	sbci	r25, 0x03	; 3
 1f8:	91 f5       	brne	.+100    	; 0x25e <adc_display+0xfe>
		{
			PORTD = 0b11111111;
 1fa:	8f ef       	ldi	r24, 0xFF	; 255
 1fc:	8b b9       	out	0x0b, r24	; 11
 1fe:	08 95       	ret
		}
	} else if (display_flag == 0)
 200:	89 2b       	or	r24, r25
 202:	69 f5       	brne	.+90     	; 0x25e <adc_display+0xfe>
	{
		if ((adc_reading >= 0) && (adc_reading <= 256))
 204:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <adc_reading>
 208:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <adc_reading+0x1>
 20c:	81 30       	cpi	r24, 0x01	; 1
 20e:	41 e0       	ldi	r20, 0x01	; 1
 210:	94 07       	cpc	r25, r20
 212:	18 f4       	brcc	.+6      	; 0x21a <adc_display+0xba>
		{
			PORTD |= 0b00000000;
 214:	8b b1       	in	r24, 0x0b	; 11
 216:	8b b9       	out	0x0b, r24	; 11
 218:	08 95       	ret
		} else if ((adc_reading >= 256) && (adc_reading <= 512))
 21a:	9c 01       	movw	r18, r24
 21c:	3a 95       	dec	r19
 21e:	21 30       	cpi	r18, 0x01	; 1
 220:	31 40       	sbci	r19, 0x01	; 1
 222:	10 f4       	brcc	.+4      	; 0x228 <adc_display+0xc8>
		{
			PORTD |= 0b00000001;
 224:	58 9a       	sbi	0x0b, 0	; 11
 226:	08 95       	ret
		} else if ((adc_reading >= 512) && (adc_reading <= 767))
 228:	9c 01       	movw	r18, r24
 22a:	32 50       	subi	r19, 0x02	; 2
 22c:	2f 3f       	cpi	r18, 0xFF	; 255
 22e:	31 05       	cpc	r19, r1
 230:	09 f0       	breq	.+2      	; 0x234 <adc_display+0xd4>
 232:	20 f4       	brcc	.+8      	; 0x23c <adc_display+0xdc>
		{
			PORTD |= 0b00000011;
 234:	8b b1       	in	r24, 0x0b	; 11
 236:	83 60       	ori	r24, 0x03	; 3
 238:	8b b9       	out	0x0b, r24	; 11
 23a:	08 95       	ret
		} else if ((adc_reading >= 767) && (adc_reading < 1023))
 23c:	9c 01       	movw	r18, r24
 23e:	2f 5f       	subi	r18, 0xFF	; 255
 240:	32 40       	sbci	r19, 0x02	; 2
 242:	2f 3f       	cpi	r18, 0xFF	; 255
 244:	31 05       	cpc	r19, r1
 246:	09 f0       	breq	.+2      	; 0x24a <adc_display+0xea>
 248:	20 f4       	brcc	.+8      	; 0x252 <adc_display+0xf2>
		{
			PORTD |= 0b00000111;
 24a:	8b b1       	in	r24, 0x0b	; 11
 24c:	87 60       	ori	r24, 0x07	; 7
 24e:	8b b9       	out	0x0b, r24	; 11
 250:	08 95       	ret
		} else if (adc_reading == 1023)
 252:	8f 3f       	cpi	r24, 0xFF	; 255
 254:	93 40       	sbci	r25, 0x03	; 3
 256:	19 f4       	brne	.+6      	; 0x25e <adc_display+0xfe>
		{
			PORTD |= 0b00001111;
 258:	8b b1       	in	r24, 0x0b	; 11
 25a:	8f 60       	ori	r24, 0x0F	; 15
 25c:	8b b9       	out	0x0b, r24	; 11
 25e:	08 95       	ret

00000260 <main>:
	}
}

int main(void)
{
	init();
 260:	0e 94 53 00 	call	0xa6	; 0xa6 <init>
	{
		if ((PINB & 0b00100000) == 0b00100000)
		{
			if ((PINB & 0b00010000) == 0b00000000)
			{
				display_flag = 1;
 264:	c1 e0       	ldi	r28, 0x01	; 1
 266:	d0 e0       	ldi	r29, 0x00	; 0
int main(void)
{
	init();
    while(1)
	{
		if ((PINB & 0b00100000) == 0b00100000)
 268:	1d 9b       	sbis	0x03, 5	; 3
 26a:	0a c0       	rjmp	.+20     	; 0x280 <main+0x20>
		{
			if ((PINB & 0b00010000) == 0b00000000)
 26c:	1c 99       	sbic	0x03, 4	; 3
 26e:	fc cf       	rjmp	.-8      	; 0x268 <main+0x8>
			{
				display_flag = 1;
 270:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <display_flag+0x1>
 274:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <display_flag>
				adc_display(display_flag);
 278:	ce 01       	movw	r24, r28
 27a:	0e 94 b0 00 	call	0x160	; 0x160 <adc_display>
 27e:	f4 cf       	rjmp	.-24     	; 0x268 <main+0x8>
			}
		} else if ((PINB & 0b00100000) == 0b00000000)
 280:	1d 99       	sbic	0x03, 5	; 3
 282:	f2 cf       	rjmp	.-28     	; 0x268 <main+0x8>
		{
			display_flag = 0;
 284:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <display_flag+0x1>
 288:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <display_flag>
			adc_display(display_flag);
 28c:	80 e0       	ldi	r24, 0x00	; 0
 28e:	90 e0       	ldi	r25, 0x00	; 0
 290:	0e 94 b0 00 	call	0x160	; 0x160 <adc_display>
 294:	e9 cf       	rjmp	.-46     	; 0x268 <main+0x8>

00000296 <__vector_16>:
		}
	}
}

ISR(TIMER0_OVF_vect)
{
 296:	1f 92       	push	r1
 298:	0f 92       	push	r0
 29a:	0f b6       	in	r0, 0x3f	; 63
 29c:	0f 92       	push	r0
 29e:	11 24       	eor	r1, r1
 2a0:	2f 93       	push	r18
 2a2:	3f 93       	push	r19
 2a4:	4f 93       	push	r20
 2a6:	5f 93       	push	r21
 2a8:	6f 93       	push	r22
 2aa:	7f 93       	push	r23
 2ac:	8f 93       	push	r24
 2ae:	9f 93       	push	r25
 2b0:	af 93       	push	r26
 2b2:	bf 93       	push	r27
 2b4:	ef 93       	push	r30
 2b6:	ff 93       	push	r31
	TCNT0 = tcnt0_start;		// set to start value based on 0.125s or 0.5s 
 2b8:	80 91 04 01 	lds	r24, 0x0104	; 0x800104 <tcnt0_start>
 2bc:	86 bd       	out	0x26, r24	; 38
	++timecount0;	// count the number of times the interrupt has been reached
 2be:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <timecount0>
 2c2:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <timecount0+0x1>
 2c6:	01 96       	adiw	r24, 0x01	; 1
 2c8:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <timecount0+0x1>
 2cc:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <timecount0>
	
	if (timecount0 >= time_delay)	// check if amount of overflows equals adc setting
 2d0:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <time_delay>
 2d4:	30 91 0b 01 	lds	r19, 0x010B	; 0x80010b <time_delay+0x1>
 2d8:	82 17       	cp	r24, r18
 2da:	93 07       	cpc	r25, r19
 2dc:	b8 f0       	brcs	.+46     	; 0x30c <__vector_16+0x76>
	{
		if ((PINB & 0b00100000) == 0b00100000)
 2de:	1d 9b       	sbis	0x03, 5	; 3
 2e0:	0b c0       	rjmp	.+22     	; 0x2f8 <__vector_16+0x62>
		{
			if ((PINB & 0b00010000) == 0b00010000)
 2e2:	1c 9b       	sbis	0x03, 4	; 3
 2e4:	13 c0       	rjmp	.+38     	; 0x30c <__vector_16+0x76>
			{
				cylon_loop(0);
 2e6:	80 e0       	ldi	r24, 0x00	; 0
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	0e 94 70 00 	call	0xe0	; 0xe0 <cylon_loop>
				timecount0 = 0;		// Restart the overflow counter
 2ee:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <timecount0+0x1>
 2f2:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <timecount0>
 2f6:	0a c0       	rjmp	.+20     	; 0x30c <__vector_16+0x76>
			}
		} else {
			cylon_loop(4);
 2f8:	84 e0       	ldi	r24, 0x04	; 4
 2fa:	90 e0       	ldi	r25, 0x00	; 0
 2fc:	0e 94 70 00 	call	0xe0	; 0xe0 <cylon_loop>
			timecount0 = 0;
 300:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <timecount0+0x1>
 304:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <timecount0>
			PORTD |= 0b00000000;
 308:	8b b1       	in	r24, 0x0b	; 11
 30a:	8b b9       	out	0x0b, r24	; 11
		}
	}
}
 30c:	ff 91       	pop	r31
 30e:	ef 91       	pop	r30
 310:	bf 91       	pop	r27
 312:	af 91       	pop	r26
 314:	9f 91       	pop	r25
 316:	8f 91       	pop	r24
 318:	7f 91       	pop	r23
 31a:	6f 91       	pop	r22
 31c:	5f 91       	pop	r21
 31e:	4f 91       	pop	r20
 320:	3f 91       	pop	r19
 322:	2f 91       	pop	r18
 324:	0f 90       	pop	r0
 326:	0f be       	out	0x3f, r0	; 63
 328:	0f 90       	pop	r0
 32a:	1f 90       	pop	r1
 32c:	18 95       	reti

0000032e <__vector_21>:

ISR (ADC_vect)	/* handles ADC interrupts  */
{
 32e:	1f 92       	push	r1
 330:	0f 92       	push	r0
 332:	0f b6       	in	r0, 0x3f	; 63
 334:	0f 92       	push	r0
 336:	11 24       	eor	r1, r1
 338:	2f 93       	push	r18
 33a:	3f 93       	push	r19
 33c:	4f 93       	push	r20
 33e:	8f 93       	push	r24
 340:	9f 93       	push	r25
	
	adc_reading = ADC;   /* ADC is in Free Running Mode - you don't have to set up anything for 
 342:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
 346:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
 34a:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <adc_reading+0x1>
 34e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <adc_reading>
						    the next conversion */
	if (adc_reading != 0) // check if new adc reading available
 352:	00 97       	sbiw	r24, 0x00	; 0
 354:	49 f1       	breq	.+82     	; 0x3a8 <__vector_21+0x7a>
	{
		adc_flag = 1; // set flag
 356:	21 e0       	ldi	r18, 0x01	; 1
 358:	30 e0       	ldi	r19, 0x00	; 0
 35a:	30 93 09 01 	sts	0x0109, r19	; 0x800109 <adc_flag+0x1>
 35e:	20 93 08 01 	sts	0x0108, r18	; 0x800108 <adc_flag>
	}
	
	if ((adc_reading < LOWER_THRESHOLD_VOLTAGE) && (adc_reading > 0)) // check adc voltage is between 0V-2.5V
 362:	9c 01       	movw	r18, r24
 364:	21 50       	subi	r18, 0x01	; 1
 366:	31 09       	sbc	r19, r1
 368:	2e 3f       	cpi	r18, 0xFE	; 254
 36a:	31 40       	sbci	r19, 0x01	; 1
 36c:	68 f4       	brcc	.+26     	; 0x388 <__vector_21+0x5a>
	{
		// 0.125s delay
		tcnt0_start = 39; // for 0.125s delay we start the timer count at 39
 36e:	87 e2       	ldi	r24, 0x27	; 39
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <tcnt0_start+0x1>
 376:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <tcnt0_start>
		time_delay = 9; // for 0.125s delay we want 9 overflows to trigger an interrupt
 37a:	89 e0       	ldi	r24, 0x09	; 9
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <time_delay+0x1>
 382:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <time_delay>
 386:	10 c0       	rjmp	.+32     	; 0x3a8 <__vector_21+0x7a>
		
	} else if ((adc_reading < UPPER_THRESHOLD_VOLTAGE) && (adc_reading > LOWER_THRESHOLD_VOLTAGE)) // otherwise if adc voltage is between 2.5V-5V
 388:	92 50       	subi	r25, 0x02	; 2
 38a:	8f 3f       	cpi	r24, 0xFF	; 255
 38c:	91 40       	sbci	r25, 0x01	; 1
 38e:	60 f4       	brcc	.+24     	; 0x3a8 <__vector_21+0x7a>
	{
		// 0.5s delay
		tcnt0_start = 142; // for 0.5s delay we start the timer count at 142
 390:	8e e8       	ldi	r24, 0x8E	; 142
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <tcnt0_start+0x1>
 398:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <tcnt0_start>
		time_delay = 55; // for 0.5s delay we want 55 overflows to trigger an interrupt
 39c:	87 e3       	ldi	r24, 0x37	; 55
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <time_delay+0x1>
 3a4:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <time_delay>
	}
 3a8:	9f 91       	pop	r25
 3aa:	8f 91       	pop	r24
 3ac:	4f 91       	pop	r20
 3ae:	3f 91       	pop	r19
 3b0:	2f 91       	pop	r18
 3b2:	0f 90       	pop	r0
 3b4:	0f be       	out	0x3f, r0	; 63
 3b6:	0f 90       	pop	r0
 3b8:	1f 90       	pop	r1
 3ba:	18 95       	reti

000003bc <_exit>:
 3bc:	f8 94       	cli

000003be <__stop_program>:
 3be:	ff cf       	rjmp	.-2      	; 0x3be <__stop_program>
